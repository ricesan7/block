<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Brick Breaker+ (GB Frame Fit + DPAD + Leaderboard)</title>

<!--
==============================================================
  ⚙️ 微調整のやり方（最重要）
  1) 下の :root の 4変数（--lcd-top / --lcd-left / --lcd-w / --lcd-h）を 0.1〜0.2% 単位で調整
  2) アウトライン表示をONにすると、キャンバス境界がピンクで表示されます
     - --lcd-outline: 1; にするとON、0 でOFF
  3) 端末回転やアドレスバー縮小に追従して自動で再レイアウトされます
==============================================================
-->
<style>
  :root{
    /* === 背景画像（ファイル名はそのまま assets/gb-frame.png を使用） ===
       画像を差し替えるだけでOK。ここは原則変更不要。 */
    --gb-frame-image: url('assets/gb-frame.png');

    /* === 液晶の相対位置とサイズ（%） ===
       すべて親(.gb-frame)に対するパーセントで指定。
       ● 微調整のコツ
         - 上に寄せたい   → --lcd-top を -0.2% ずつ
         - 下に隙間あり   → --lcd-h を +0.2%（下へ広げる）
         - 右に隙間あり   → --lcd-w を +0.2%（右へ広げる）or --lcd-left を +0.2%（全体を右へ）
         - 左に当たってる → --lcd-left を +0.2%（右へ）
       ※ 値は 2桁小数まで詰めると綺麗に収まります。
    */
    --lcd-top: 12.20%;
    --lcd-left: 14.80%;
    --lcd-w: 70.40%;
    --lcd-h: 40.60%;

    /* === デバッグ用アウトライン（0:OFF / 1:ON） === */
    --lcd-outline: 1;

    /* ===== 以降は配色・コントローラ設定 ===== */
    --bg:#1a1a1a; --bg2:#0d0d0d; --fg:#e0e0c0; --accent:#f0d060; --muted:#a0a080;
    --brick:#d04040; --brick2:#40a040; --brick3:#4060d0;
    --green:#50c878; --yellow:#f0e68c; --glass:#222222aa;

    --ctrl-surface:#1d2b1d; --ctrl-border:#b8d38b; --ctrl-dpad:#2f3a2f; --ctrl-dpad-fg:#cfe6a3;
    --ctrl-a:#7b2f6a; --ctrl-b:#5e2552; --ctrl-ab-fg:#e6ffd2; --ctrl-shadow:rgba(0,0,0,.45);
    --btn-base:56px; --gap-base:8px; --pad-scale:1;
  }

  html, body { height: 100svh; overflow: hidden; }
  body {
    margin:0; font-family: ui-monospace, Menlo, Consolas, monospace;
    background: var(--bg2); color: var(--fg);
    display:grid; min-height:100svh; place-items:start center;
    -webkit-user-select:none; user-select:none; overscroll-behavior:none;
    -webkit-touch-callout:none; -webkit-tap-highlight-color: transparent;
  }

  .wrap { width:min(980px, 96vw); padding:8px 8px calc(env(safe-area-inset-bottom, 0) + 8px); }
  header { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px; }
  h1 { font-size:14px; margin:0; color:var(--accent); letter-spacing:1px; }
  .controls { display:flex; gap:6px; flex-wrap:wrap; }
  button { padding:6px 10px; border-radius:4px; border:2px solid var(--fg); background: var(--bg); color:var(--fg); cursor:pointer; font-family:inherit; font-size:10px; }
  button:hover { background: var(--fg); color: var(--bg); }
  .panel { display:flex; align-items:center; gap:8px; color:var(--muted); flex-wrap:wrap; padding:4px 6px; border-radius:4px; background: var(--glass); border:2px solid var(--fg); font-size:10px; }
  .badge { padding:1px 4px; border-radius:2px; border:1px solid var(--fg); background:var(--bg2); font-size:9px; color:var(--accent); }
  .score { font-weight:700; color:var(--accent); }

  /* === GBフレーム（背景） === */
  .gb-frame{
    position: relative;
    width: 100vw; height: 100svh;
    background: var(--gb-frame-image) no-repeat center / contain;
    overflow: hidden;
  }
  /* ここが液晶の枠。変数で位置とサイズを決める */
  .gb-frame #screen{
    position: absolute;
    top:   var(--lcd-top);
    left:  var(--lcd-left);
    width: var(--lcd-w);
    height:var(--lcd-h);
    background: #111; border: none; image-rendering: pixelated;
    outline: calc(var(--lcd-outline) * 2px) solid rgba(255,0,200,.65); /* 調整が終わったら --lcd-outline:0; */
  }

  footer { margin-top:6px; font-size:9px; color:var(--muted); display:flex; justify-content:space-between; gap:6px; flex-wrap:wrap; }
  kbd { background:var(--bg); border:1px solid var(--fg); padding:1px 3px; font-family:inherit; font-size:9px; }

  /* === コントローラ（モバイル） === */
  .mobile-pad { display:none; justify-content:space-between; align-items:center; gap:16px; margin-top:8px; padding:10px 6px;
    background:var(--ctrl-surface); border:2px solid var(--ctrl-border); border-radius:8px;
    transform: scale(var(--pad-scale)); transform-origin: bottom center;
  }
  .mobile-pad .dpad {
    display:grid;
    grid-template-columns: calc(var(--btn-base)*var(--pad-scale)) calc(var(--btn-base)*var(--pad-scale)) calc(var(--btn-base)*var(--pad-scale));
    grid-template-rows:    calc(var(--btn-base)*var(--pad-scale)) calc(var(--btn-base)*var(--pad-scale)) calc(var(--btn-base)*var(--pad-scale));
    gap: calc(var(--gap-base)*var(--pad-scale));
  }
  .mobile-pad .dpad .spacer { visibility:hidden; }
  .mobile-pad .buttons { display:flex; align-items:center; gap:18px; }
  .mobile-pad button {
    width:calc(var(--btn-base)*var(--pad-scale)); height:calc(var(--btn-base)*var(--pad-scale));
    border-radius:8px; font-size:calc(16px*var(--pad-scale));
    touch-action:none; background:var(--bg2); border:2px solid var(--ctrl-border); color:var(--fg);
    font-family:inherit; box-shadow: 0 2px 0 var(--ctrl-shadow); transition: transform .02s ease;
  }
  .mobile-pad button:active, .mobile-pad button.pressed { transform: translateY(1px); box-shadow: 0 1px 0 var(--ctrl-shadow); }
  #dpadUp, #dpadDown, #dpadLeft, #dpadRight { background: var(--ctrl-dpad); color: var(--ctrl-dpad-fg); }
  #btnA, #btnB { border-radius: 999px; color: var(--ctrl-ab-fg); }
  #btnA { background: var(--ctrl-a); }  #btnB { background: var(--ctrl-b); }
  @media (max-width: 768px){ .mobile-pad { display:flex; } }

  /* === Overlay (ゲームオーバー/ランキング) === */
  .overlay { position: fixed; inset: 0; display:none;
    align-items:center; justify-content:center; background: rgba(0,0,0,.6); z-index: 9999; }
  .overlay.show { display:flex; }
  .card { width:min(540px, 94vw); max-height:90vh; overflow:auto; background:#101010; color:var(--fg); border:2px solid var(--fg);
    border-radius:8px; padding:16px; box-shadow: 0 10px 40px rgba(0,0,0,.6); }
  .card h2 { margin:0 0 10px; color:var(--accent); font-size:20px; }
  .big { font-size:36px; font-weight:700; color:var(--accent); margin-bottom:8px; }
  .ranklist { margin:8px 0 12px; padding:0; list-style:none; border-top:1px solid var(--fg); border-bottom:1px solid var(--fg); }
  .ranklist li { display:flex; justify-content:space-between; padding:6px 2px; border-bottom:1px dashed #333; }
  .ranklist li:last-child { border-bottom:none; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .row input { border:2px solid var(--fg); background:#0b0b0b; color:var(--fg); border-radius:4px; padding:6px 8px; font-family:inherit; font-size:14px; }
  .row button { font-size:12px; padding:8px 10px; }
  .note { color:var(--muted); font-size:11px; }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Brick Breaker+ GB Frame</h1>
      <div class="controls">
        <button id="btnStart">▶︎/⏸</button>
        <button id="btnReset">⟲</button>
      </div>
    </header>

    <div class="panel" id="scorePanel">
      <div>SCORE:<span id="score" class="score">0</span></div>
      <div>LIVES:<span id="lives">3</span></div>
      <div>LV:<span id="level">1</span></div>
      <div>x<span id="mult">1.00</span></div>
      <div>FPS:<span id="fps">0</span></div>
      <div id="powerBadges" class="badge">NO POWER</div>
    </div>

    <!-- GBフレーム：背景画像の“液晶”位置にはめ込み -->
    <div class="gb-frame">
      <canvas id="screen" aria-label="game screen" role="img"></canvas>
    </div>

    <!-- Controller -->
    <div class="mobile-pad" id="mobilePad" aria-label="virtual controls">
      <div class="dpad">
        <span class="spacer"></span><button id="dpadUp">▲</button><span class="spacer"></span>
        <button id="dpadLeft">◀</button><span class="spacer"></span><button id="dpadRight">▶</button>
        <span class="spacer"></span><button id="dpadDown">▼</button><span class="spacer"></span>
      </div>
      <div class="buttons">
        <button id="btnA">A</button>
        <button id="btnB">B</button>
      </div>
    </div>

    <footer>
      <div><kbd>←</kbd><kbd>→</kbd> MOVE / <kbd>SPACE</kbd>● LAUNCH / <kbd>P</kbd> PAUSE</div>
    </footer>
  </div>

  <!-- Overlay: GameOver + Leaderboard -->
  <div class="overlay" id="overlay">
    <div class="card">
      <h2>GAME OVER</h2>
      <div class="big">SCORE: <span id="finalScore">0</span></div>
      <h3 style="margin:10px 0 6px;">Top 10</h3>
      <ul class="ranklist" id="rankList"></ul>
      <div id="entryRow" class="row" style="display:none;">
        <input id="playerName" maxlength="16" placeholder="Your name (max 16)" />
        <button id="btnSubmit">Submit</button>
      </div>
      <div class="row" style="margin-top:10px;">
        <button id="btnPlayAgain">Play Again</button>
        <span id="syncStatus" class="note"></span>
      </div>
      <p class="note" style="margin-top:8px;">
        ランキングはローカル保存（この端末のみ）＋任意でGoogleスプレッドシート連携に対応。
      </p>
    </div>
  </div>

  <!-- ====== 液晶フィット：CSSサイズ→内部解像度へ反映 ====== -->
  <script>
    // 誤操作対策（範囲選択・ダブルタップズームなどを抑制）
    ['touchmove','wheel'].forEach(t=>{
      document.addEventListener(t, e=>{ if((e.touches?.length||0)>1) e.preventDefault(); }, {passive:false});
    });
    document.addEventListener('gesturestart', e=>e.preventDefault());

    const canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d');

    function syncCanvasSizeFrame(){
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const cssW = Math.max(1, Math.floor(rect.width));
      const cssH = Math.max(1, Math.floor(rect.height));
      canvas.width  = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      if (typeof onCanvasResized === 'function') onCanvasResized(cssW, cssH);
    }
    function ensureFrameSync(){ requestAnimationFrame(()=>setTimeout(syncCanvasSizeFrame, 0)); }
    window.addEventListener('load', ensureFrameSync);
    window.addEventListener('resize', ensureFrameSync);
    window.addEventListener('orientationchange', ensureFrameSync);
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', ensureFrameSync);
      window.visualViewport.addEventListener('scroll', ensureFrameSync);
    }
    const gbFrameEl = document.querySelector('.gb-frame');
    if (gbFrameEl && 'ResizeObserver' in window) new ResizeObserver(ensureFrameSync).observe(gbFrameEl);
  </script>

  <!-- ====== ゲーム本体 ====== -->
  <script>
  /* === DOM refs === */
  const $ = id => document.getElementById(id);
  const startBtn=$('btnStart'), resetBtn=$('btnReset');
  const scoreEl=$('score'), livesEl=$('lives'), levelEl=$('level'), multEl=$('mult'), powerEl=$('powerBadges'), fpsEl=$('fps');
  const overlay=$('overlay'), finalScoreEl=$('finalScore'), rankList=$('rankList');
  const entryRow=$('entryRow'), nameInput=$('playerName'), submitBtn=$('btnSubmit'), playAgainBtn=$('btnPlayAgain'), syncStatus=$('syncStatus');

  /* === Colors === */
  const CSSV=getComputedStyle(document.documentElement);
  const COLOR={
    brick: CSSV.getPropertyValue('--brick').trim()||'#d04040',
    brick2:CSSV.getPropertyValue('--brick2').trim()||'#40a040',
    brick3:CSSV.getPropertyValue('--brick3').trim()||'#4060d0',
    green: CSSV.getPropertyValue('--green').trim()||'#50c878',
    yellow:CSSV.getPropertyValue('--yellow').trim()||'#f0e68c',
    fg:    CSSV.getPropertyValue('--fg').trim()||'#e0e0c0',
    bg:    CSSV.getPropertyValue('--bg').trim()||'#1a1a1a'
  };

  /* === World === */
  let W=480,H=720, STEP=1/120, playing=false, last=performance.now(), acc=0, time=0;
  const PADDLE={w:104,h:16,speed:600,minW:64,maxW:240};
  const BALL={r:8,baseSpeed:480};
  const WALL={pad:10};
  let score=0,lives=3,level=1;
  let multiplier=1.00, MULT_INC=0.10, MULT_MAX=5.00;

  // Slow（速度スケールで減速→時間で復帰）
  let speedScale=1.0, targetSpeedScale=1.0;
  const SLOW_SCALE=0.70, SPEED_RECOVER_RATE=4.0; // 1秒当たりの復帰係数
  const effects={expand:0,slow:0};

  /* === Input === */
  const keys=new Set();
  window.addEventListener('keydown',e=>{ if(["ArrowLeft","ArrowRight"," ","p","P"].includes(e.key)) e.preventDefault(); keys.add(e.key);});
  window.addEventListener('keyup',e=>keys.delete(e.key));
  const mobile={left:false,right:false,launch:false};
  function bindHold(id,on,off){ const b=$(id); if(!b) return; const d=e=>{e.preventDefault();on();}; const u=e=>{e.preventDefault();off();}; b.addEventListener('pointerdown',d,{passive:false}); ["pointerup","pointerleave","pointercancel"].forEach(ev=>b.addEventListener(ev,u,{passive:false})); }
  bindHold('dpadLeft',()=>mobile.left=true,()=>mobile.left=false);
  bindHold('dpadRight',()=>mobile.right=true,()=>mobile.right=false);
  bindHold('dpadUp',()=>{},()=>{}); bindHold('dpadDown',()=>{},()=>{});
  $('btnA')?.addEventListener('pointerdown',e=>{e.preventDefault(); mobile.launch=true;},{passive:false});
  $('btnB')?.addEventListener('pointerdown',e=>{e.preventDefault(); playing=!playing; startBtn.textContent=playing?'⏸':'▶︎';},{passive:false});
  $('mobilePad')?.querySelectorAll('button').forEach(btn=>{
    btn.addEventListener('pointerdown',()=>btn.classList.add('pressed'));
    ["pointerup","pointerleave","pointercancel"].forEach(ev=>btn.addEventListener(ev,()=>btn.classList.remove('pressed')));
  });

  /* === SFX === */
  let actx; function beep(freq=660,dur=0.05,type='square'){ try{ actx=actx||new (window.AudioContext||window.webkitAudioContext)(); const o=actx.createOscillator(), g=actx.createGain(); o.type=type; o.frequency.value=freq; o.connect(g); g.connect(actx.destination); g.gain.setValueAtTime(0.08, actx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime+dur); o.start(); o.stop(actx.currentTime+dur);}catch(_){ } }

  /* === Entities === */
  const paddle={x:0,y:0,w:PADDLE.w,h:PADDLE.h};
  const clamp=(v,a,b)=>Math.min(Math.max(v,a),b);
  function newBall(){ return {x:paddle.x+paddle.w/2,y:paddle.y-BALL.r-1,vx:0,vy:0,r:BALL.r,stuck:true,trail:[]}; }
  let balls=[newBall()];
  const BR={cols:10,rows:9,pad:6,h:18}; let bricks=[];
  const PU_TYPES=['E','S','M','L']; let powerups=[];

  function makeLevel(n){
    bricks.length=0;
    const margin=WALL.pad, usableW=W-margin*2;
    const bw=Math.floor((usableW-(BR.cols-1)*BR.pad)/BR.cols);
    const top=Math.max(36,Math.round(H*0.08));
    for(let r=0;r<BR.rows;r++){
      for(let c=0;c<BR.cols;c++){
        const x=margin + c*(bw+BR.pad), y=top + r*(BR.h+BR.pad);
        let hp=1 + (r>>1) + Math.floor((n-1)/2);
        const color = r<3? COLOR.brick : r<6? COLOR.brick2 : COLOR.brick3;
        if(color===COLOR.brick3) hp=1; // 青は常に1発
        bricks.push({x,y,w:bw,h:BR.h,hp,alive:true,color});
      }
    }
  }
  function resetBallAndPaddle(){ balls=[newBall()]; }
  function launchBallAll(){
    for(const b of balls){
      if(b.stuck){
        const ang=(-60+Math.random()*20)*Math.PI/180;
        const sp=BALL.baseSpeed; // 基準速度、減速は speedScale で
        b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;
        b.stuck=false; b.trail.length=0;
      }
    }
    beep(880,0.05,'square');
  }

  /* === Collision / Effects === */
  function circleRectHit(cx,cy,cr, rx,ry,rw,rh){ const nx=clamp(cx,rx,rx+rw), ny=clamp(cy,ry,ry+rh); const dx=cx-nx, dy=cy-ny; return (dx*dx+dy*dy)<=cr*cr; }
  function reflectCircleFromRect(cx,cy,r, vx,vy, rx,ry,rw,rh){ const nx=clamp(cx,rx,rx+rw), ny=clamp(cy,ry,ry+rh); const dx=cx-nx, dy=cy-ny; if(Math.abs(dx)>Math.abs(dy)) return {vx:-vx, vy}; if(Math.abs(dy)>Math.abs(dx)) return {vx, vy:-vy}; return {vx:-vx, vy:-vy}; }
  let particles=[]; function burst(x,y,color){ for(let i=0;i<8;i++) particles.push({x,y,vx:(Math.random()*2-1)*120,vy:(Math.random()*2-1)*120,life:0.35,color}); }

  function spawnPowerUp(x,y){ if(Math.random()<0.22){ const type=PU_TYPES[Math.floor(Math.random()*PU_TYPES.length)]; powerups.push({x,y,v:120,type,alive:true}); } }
  function applyPowerUp(t){
    if(t==='E'){ effects.expand=12; paddle.w=clamp(Math.round(paddle.w*1.5),PADDLE.minW,PADDLE.maxW); beep(660,0.08,'square'); }
    if(t==='S'){ effects.slow=8; targetSpeedScale=SLOW_SCALE; beep(330,0.08,'sine'); }
    if(t==='M'){ const clones=[]; for(const b of balls){ if(!b.stuck){ clones.push({x:b.x,y:b.y,vx:-b.vx,vy:b.vy,r:b.r,stuck:false,trail:[]}); } } balls.push(...clones); beep(520,0.08,'triangle'); }
    if(t==='L'){ lives++; livesEl.textContent=String(lives); beep(990,0.08,'square'); }
    updateBadges();
  }
  function updateBadges(){ const tags=[]; if(effects.expand>0) tags.push('E'); if(effects.slow>0) tags.push('S'); powerEl.textContent=tags.length?('POWER:'+tags.join(',')):'NO POWER'; multEl.textContent=multiplier.toFixed(2); }

  /* === Leaderboard (local + optional remote) === */
  const LEADERBOARD_ENDPOINT = ''; // GASのWebアプリURLを入れるとグローバル共有可
  const LB_LOCAL_KEY = 'bb_local_scores_v1';
  const LB_LIMIT = 10;
  function loadLocalScores(){ try{ return JSON.parse(localStorage.getItem(LB_LOCAL_KEY)||'[]'); }catch(_){ return []; } }
  function saveLocalScores(arr){ localStorage.setItem(LB_LOCAL_KEY, JSON.stringify(arr.slice(0,LB_LIMIT))); }
  async function fetchGlobalScores(){ if(!LEADERBOARD_ENDPOINT) return null; try{ const r=await fetch(LEADERBOARD_ENDPOINT+'?mode=list',{cache:'no-store'}); if(!r.ok) throw 0; const data=await r.json(); return Array.isArray(data)?data.slice(0,LB_LIMIT):null; }catch{ return null; } }
  async function submitGlobalScore(name, score){ if(!LEADERBOARD_ENDPOINT) return {ok:false}; try{ const r=await fetch(LEADERBOARD_ENDPOINT,{method:'POST',body:JSON.stringify({mode:'submit',name,score,ts:Date.now()})}); let j=null; try{ j=await r.json(); }catch(_){ } return { ok:!!(j&&j.ok) }; }catch{ return {ok:false}; } }
  function mergeAndTrim(localArr, add){ return [...localArr, add].sort((a,b)=>b.score-a.score).slice(0,LB_LIMIT); }
  function qualifiesLocal(finalScore){ const arr=loadLocalScores(); if(arr.length<LB_LIMIT) return true; const min=arr[arr.length-1]?.score??-Infinity; return finalScore>min; }
  function renderRankList(items){ rankList.innerHTML = items.map((r,i)=>`<li><span>#${i+1}. ${r.name||'---'}</span><strong>${r.score}</strong></li>`).join('') || '<li>No records</li>'; }

  async function showGameOver(finalScore){
    playing=false; startBtn.textContent='▶︎';
    finalScoreEl.textContent=String(finalScore);
    overlay.classList.add('show');
    syncStatus.textContent = LEADERBOARD_ENDPOINT ? 'Syncing…' : '（ローカル保存のみ。スプレッドシート連携は後述URL設定）';
    let local = loadLocalScores().sort((a,b)=>b.score-a.score).slice(0,LB_LIMIT);
    renderRankList(local);
    let global = await fetchGlobalScores();
    if(global){ renderRankList(global); syncStatus.textContent='Global Top10'; }
    else if(LEADERBOARD_ENDPOINT){ syncStatus.textContent='グローバル取得失敗'; }
    entryRow.style.display = qualifiesLocal(finalScore) ? 'flex' : 'none';
    if(entryRow.style.display!=='none'){ nameInput.value=''; nameInput.focus(); }
    submitBtn.onclick = async ()=>{
      const name=(nameInput.value||'NONAME').slice(0,16);
      const merged=mergeAndTrim(loadLocalScores(),{name,score:finalScore,ts:Date.now()});
      saveLocalScores(merged); renderRankList(merged);
      if(LEADERBOARD_ENDPOINT){
        syncStatus.textContent='Submitting…';
        const r=await submitGlobalScore(name,finalScore);
        syncStatus.textContent = r.ok?'Submitted':'グローバル通信失敗';
        if(r.ok){ const g=await fetchGlobalScores(); if(g) renderRankList(g); }
      }
      entryRow.style.display='none';
    };
    playAgainBtn.onclick=()=>{ overlay.classList.remove('show'); score=0; level=1; lives=3; multiplier=1.0;
      scoreEl.textContent='0'; levelEl.textContent='1'; livesEl.textContent='3'; multEl.textContent='1.00';
      makeLevel(level); resetBallAndPaddle(); playing=true; startBtn.textContent='⏸'; };
  }

  /* === Resizing hook === */
  function onCanvasResized(cssW, cssH){
    W=cssW; H=cssH;
    paddle.w=clamp(paddle.w||PADDLE.w, PADDLE.minW, PADDLE.maxW);
    paddle.h=PADDLE.h;
    paddle.x=clamp(paddle.x||(W/2 - paddle.w/2), WALL.pad, W - WALL.pad - paddle.w);
    paddle.y=Math.round(H - 56);
    makeLevel(level);
    resetBallAndPaddle();
  }

  /* === Step / Render / Loop === */
  function step(dt){
    time+=dt;
    if(effects.expand>0){ effects.expand-=dt; if(effects.expand<=0){ paddle.w=clamp(PADDLE.w,PADDLE.minW,PADDLE.maxW); } }
    if(effects.slow>0){ effects.slow-=dt; targetSpeedScale=SLOW_SCALE; } else { targetSpeedScale=1.0; }
    const k=Math.min(1, dt*4.0); speedScale += (targetSpeedScale - speedScale) * k;

    let vx=0; if(keys.has('ArrowLeft')||mobile.left) vx-=PADDLE.speed; if(keys.has('ArrowRight')||mobile.right) vx+=PADDLE.speed;
    paddle.x=clamp(paddle.x+vx*dt, WALL.pad, W-WALL.pad-paddle.w);
    if(keys.has(' ')||mobile.launch){ launchBallAll(); mobile.launch=false; }
    if(keys.has('p')||keys.has('P')){ playing=false; keys.delete('p'); keys.delete('P'); startBtn.textContent='▶︎'; }

    const effDt=dt*speedScale;
    for(const b of balls){
      if(b.stuck){ b.x=paddle.x+paddle.w/2; b.y=paddle.y-b.r-1; b.trail.length=0; continue; }
      b.trail.push({x:b.x,y:b.y,life:0.25}); if(b.trail.length>14) b.trail.shift(); for(const t of b.trail){ t.life-=dt; }
      b.x+=b.vx*effDt; b.y+=b.vy*effDt;
      if(b.x-b.r<=WALL.pad){ b.x=WALL.pad+b.r; b.vx*=-1; beep(440,0.02); }
      if(b.x+b.r>=W-WALL.pad){ b.x=W-WALL.pad-b.r; b.vx*=-1; beep(440,0.02); }
      if(b.y-b.r<=WALL.pad){ b.y=WALL.pad+b.r; b.vy*=-1; beep(440,0.02); }
      if(b.y-b.r>H){
        balls.splice(balls.indexOf(b),1);
        if(balls.length===0){
          lives--; multiplier=1.0;
          livesEl.textContent=String(lives); multEl.textContent=multiplier.toFixed(2);
          if(lives<=0){
            const final=score; showGameOver(final);
            level=1; score=0; lives=3; multiplier=1.0;
            levelEl.textContent='1'; scoreEl.textContent='0'; livesEl.textContent='3'; multEl.textContent='1.00';
            makeLevel(level);
          }
          resetBallAndPaddle();
        }
        break;
      }
      if(circleRectHit(b.x,b.y,b.r, paddle.x,paddle.y,paddle.w,paddle.h) && b.vy>0){
        const hit=((b.x-(paddle.x+paddle.w/2))/(paddle.w/2));
        const ang=(-75+60*hit)*Math.PI/180;
        const sp=Math.hypot(b.vx,b.vy);
        b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;
        b.y=paddle.y-b.r-1; beep(620,0.03);
      }
    }

    outer: for(const b of balls){
      if(b.stuck) continue;
      for(const br of bricks){
        if(!br.alive) continue;
        if(circleRectHit(b.x,b.y,b.r, br.x,br.y,br.w,br.h)){
          const r=reflectCircleFromRect(b.x,b.y,b.r,b.vx,b.vy,br.x,br.y,br.w,br.h);
          b.vx=r.vx; b.vy=r.vy; br.hp--; burst(b.x,b.y,br.color); beep(800,0.03,'triangle');
          const add = Math.round(50 * multiplier); score += add; scoreEl.textContent=String(score);
          multiplier = Math.min(MULT_MAX, +(multiplier + 0.10).toFixed(2)); multEl.textContent = multiplier.toFixed(2);
          if(br.hp<=0){ br.alive=false; spawnPowerUp(br.x+br.w/2, br.y+br.h/2); }
          break outer;
        }
      }
    }

    for(const p of powerups){ if(!p.alive) continue; p.y+=120*dt; if(p.y>H+20) p.alive=false;
      if(circleRectHit(p.x,p.y,10, paddle.x,paddle.y,paddle.w,paddle.h)){ p.alive=false; applyPowerUp(p.type); }}
    powerups=powerups.filter(p=>p.alive!==false);

    for(const pt of particles){ pt.x+=pt.vx*dt; pt.y+=pt.vy*dt; pt.vx*=0.98; pt.vy*=0.98; pt.life-=dt; }
    particles=particles.filter(pt=>pt.life>0);

    if(bricks.every(b=>!b.alive)){ level++; levelEl.textContent=String(level); makeLevel(level); resetBallAndPaddle(); }
    updateBadges();
  }

  function drawBackground(){ ctx.fillStyle=COLOR.bg; ctx.fillRect(0,0,W,H); ctx.strokeStyle=COLOR.fg; ctx.lineWidth=2; ctx.strokeRect(WALL.pad+1,WALL.pad+1, W-2*WALL.pad-2, H-2*WALL.pad-2); }
  function rrect(x,y,w,h){ ctx.fillRect(x,y,w,h); }
  function drawPaddle(){ ctx.fillStyle=COLOR.fg; rrect(paddle.x,paddle.y,paddle.w,paddle.h); }
  function drawBalls(){ ctx.fillStyle=COLOR.fg; for(const b of balls){ for(const t of b.trail){ const a=Math.max(0,t.life/0.25); if(a<=0) continue; ctx.globalAlpha=a*0.6; ctx.fillRect(Math.round(t.x)-2, Math.round(t.y)-2, 4, 4); } ctx.globalAlpha=1; ctx.fillRect(Math.round(b.x)-2, Math.round(b.y)-2, 4, 4); } }
  function drawBricks(){ for(const br of bricks){ if(!br.alive) continue; ctx.fillStyle=br.color; rrect(br.x,br.y,br.w,br.h); ctx.strokeStyle=COLOR.fg; ctx.lineWidth=1; ctx.strokeRect(br.x+0.5,br.y+0.5,br.w-1,br.h-1); } }
  function drawPowerUps(){ for(const p of powerups){ ctx.fillStyle = p.type==='E'? COLOR.green : p.type==='S'? COLOR.yellow : '#88b0ff'; ctx.fillRect(p.x-6,p.y-6,12,12); ctx.fillStyle = COLOR.bg; ctx.fillText(p.type, p.x-3, p.y+3); } }
  function drawParticles(){ ctx.fillStyle=COLOR.fg; for(const pt of particles){ ctx.globalAlpha=Math.max(0,pt.life/0.35); ctx.fillRect(pt.x,pt.y,2,2); } ctx.globalAlpha=1; }
  function render(){ ctx.clearRect(0,0,W,H); drawBackground(); drawBricks(); drawPaddle(); drawBalls(); ctx.font='10px ui-monospace, monospace'; drawPowerUps(); drawParticles(); }

  let fpsCount=0, fpsTime=performance.now();
  function fpsTick(){ fpsCount++; const now=performance.now(); if(now-fpsTime>=500){ const fps=Math.round(1000*fpsCount/(now-fpsTime)); fpsEl.textContent=String(fps); fpsTime=now; fpsCount=0; } }
  function loop(t){ if(!playing){ last=t; requestAnimationFrame(loop); return; } let dt=(t-last)/1000; last=t; dt=Math.min(dt,0.05); acc+=dt; while(acc>=STEP){ step(STEP); acc-=STEP; } render(); fpsTick(); requestAnimationFrame(loop); }

  function initGame(){ makeLevel(level); resetBallAndPaddle(); playing=false; startBtn.textContent='▶︎'; requestAnimationFrame(loop); }
  startBtn?.addEventListener('click', ()=>{ playing=!playing; startBtn.textContent=playing?'⏸':'▶︎'; });
  resetBtn?.addEventListener('click', ()=>{ score=0; level=1; lives=3; multiplier=1.0;
    scoreEl.textContent='0'; levelEl.textContent='1'; livesEl.textContent='3'; multEl.textContent='1.00';
    makeLevel(level); resetBallAndPaddle(); playing=false; startBtn.textContent='▶︎'; });

  window.addEventListener('load', ()=>{ setTimeout(()=>{ initGame(); }, 0); });
  </script>
</body>
</html>
